module Steiner.Language.Error where

import Prelude
import Data.Maybe (Maybe(..))
import Data.String (joinWith)
import Data.Tuple (Tuple(..), curry, uncurry)
import Data.Variant (SProxy(..), Variant, inj, match)
import Steienr.Data.String (indent)
import Steiner.Language.Type (Type(..))

-- |
-- Kind of errors which can occur during type inference
--
type InferenceErrorKinds r
  = ( notInScope :: String
    | r
    )

-- |
-- Pretty print an inference error
--
showInferenceError :: Variant (InferenceErrorKinds ()) -> String
showInferenceError =
  (prefix <> _)
    <<< match
        { notInScope: \name -> "Variable " <> name <> " is not in scope"
        }
  where
  prefix = "InferenceError: "

-- |
-- Helper to create a notInScope error
--
notInScope :: String -> InferenceErrors
notInScope name =
  SteinerError
    { error: inj (SProxy :: SProxy "notInScope") name
    , showErr: showInferenceError
    }

-- |
-- Details for errors generated by the fact a type contains references to itself
--
type RecursiveTypeDetails
  = { ty :: Type
    , varName :: String
    }

-- |
-- Kind of errors which can occur during unification
--
type UnificationErrorKinds r
  = ( cannotUnify :: Tuple Type Type
    , notPolymorphicEnough :: Tuple Type Type
    , noSkolemScope :: Tuple String Type
    , recursiveType :: RecursiveTypeDetails
    , differentSkolemConstants :: Tuple String String
    | r
    )

-- |
-- Pretty print an inference error
--
showUnificationError :: Variant (UnificationErrorKinds ()) -> String
showUnificationError =
  (prefix <> _)
    <<< match
        { recursiveType:
          \{ ty, varName } ->
            "Type\n"
              <> (indent 4 $ varName <> " = " <> show ty)
              <> "\ncontains a reference to itself."
        , notPolymorphicEnough:
          uncurry \ty ty' ->
            joinWith "\n"
              [ "Type"
              , indent 4 $ show ty'
              , "is less polymorphic than type"
              , indent 4 $ show ty
              ]
        , cannotUnify:
          \(Tuple left right) ->
            joinWith "\n"
              [ "Cannot unify type"
              , indent 4 $ show left
              , "with type"
              , indent 4 $ show right
              ]
        , noSkolemScope:
          uncurry \ident ty ->
            joinWith "\n"
              [ "The impossible happened! Cannot find skolem scope for type: "
              , indent 4 $ show $ TForall ident ty Nothing
              ]
        , differentSkolemConstants:
          uncurry \left right ->
            joinWith "\n"
              [ "Cannot unify type"
              , indent 4 left
              , "with type"
              , indent 4 right
              , "because the skolem constants do not match"
              ]
        }
  where
  prefix = "UnificationError: "

-- |
-- Helper to create a recursiveType error
--
recursiveType :: RecursiveTypeDetails -> UnificationErrors
recursiveType data' =
  SteinerError
    { error: inj (SProxy :: SProxy "recursiveType") data'
    , showErr: showUnificationError
    }

-- |
-- Helper to create a noSkolemScope error
--
noSkolemScope :: String -> Type -> UnificationErrors
noSkolemScope =
  curry \data' ->
    SteinerError
      { error: inj (SProxy :: SProxy "noSkolemScope") data'
      , showErr: showUnificationError
      }

-- |
-- Helper to create a cannotUnify error
--
cannotUnify :: Type -> Type -> UnificationErrors
cannotUnify left right =
  SteinerError
    { error: inj (SProxy :: SProxy "cannotUnify") $ Tuple left right
    , showErr: showUnificationError
    }

-- |
-- Helper to create a notPolymorphicEnough error
--
notPolymorphicEnough :: Type -> Type -> UnificationErrors
notPolymorphicEnough left right =
  SteinerError
    { error: inj (SProxy :: SProxy "notPolymorphicEnough") $ Tuple left right
    , showErr: showUnificationError
    }

-- |
-- Helper to create a differentSkolemConstants error
--
differentSkolemConstants :: String -> String -> UnificationErrors
differentSkolemConstants left right =
  SteinerError
    { error: inj (SProxy :: SProxy "differentSkolemConstants") $ Tuple left right
    , showErr: showUnificationError
    }

-- |
-- Errors which occur during unification
--
type UnificationErrors
  = SteinerError (UnificationErrorKinds ())

-- |
-- General type for errors
--
newtype SteinerError e
  = SteinerError
  { error :: Variant e
  , showErr :: Variant e -> String
  }

-- |
-- Errors which occur during type infernece
--
type InferenceErrors
  = SteinerError (InferenceErrorKinds ())

instance showSteinerError :: Show (SteinerError e) where
  show (SteinerError { error, showErr }) = showErr error
