module Steiner.Language.Type where

import Prelude
import Control.Monad.Error.Class (class MonadError, throwError)
import Data.List (List(..))
import Data.Map as Map
import Data.Maybe (Maybe(..), fromMaybe)
import Data.String (joinWith)
import Data.Tuple (Tuple(..))
import Data.Variant (SProxy(..), Variant, inj, match)
import Steienr.Data.String (indent)
import Steiner.Control.Monad.Unify (class Incomplete, class Substituable, class Unifiable, Substitution(..), UnifyT, Unknown, (?=), (~))
import Steiner.Language.Error (SteinerError(..))

-- |
-- Types for the Steiner type system
--
data Type
  -- Types we don't know the value of
  = TUnknown Unknown
  -- Lambda types (will be converted to TConstant later)
  | TLambda Type Type
  -- Opaque types like Int or String
  | TConstant String

derive instance eqType :: Eq Type

-- |
-- Check if a type is a function 
--
isFunction :: Type -> Boolean
isFunction (TLambda _ _) = true

isFunction _ = false

-- Types for literals
typeInt :: Type
typeInt = TConstant "Int"

typeFloat :: Type
typeFloat = TConstant "Float"

typeString :: Type
typeString = TConstant "String"

typeBoolean :: Type
typeBoolean = TConstant "Boolean"

instance showType :: Show Type where
  show (TUnknown num) = "t" <> show num
  show (TConstant name) = name
  show (TLambda from to) = prefix <> " -> " <> show to
    where
    prefix = if isFunction from then "(" <> show from <> ")" else show from

instance substituableType :: Substituable Type Type where
  applySubstitution subst (TLambda from to) = TLambda (subst ?= from) (subst ?= to)
  applySubstitution (Substitution subst) ty@(TUnknown name) = fromMaybe ty $ Map.lookup name subst
  applySubstitution _ ty = ty

instance incompleteType :: Incomplete Type where
  unknown = TUnknown
  isUnknown (TUnknown name) = Just name
  isUnknown _ = Nothing
  unknowns = mempty

instance unifiableType :: MonadError UnificationErrors m => Unifiable m Type where
  unify (TUnknown name) ty = bindVariable name ty
  unify ty (TUnknown name) = bindVariable name ty
  unify (TLambda from to) (TLambda from' to') = do
    subst <- from ~ from'
    subst' <- subst ?= to ~ subst ?= to'
    pure $ subst' <> subst
  unify left right
    | left == right = pure mempty
    | otherwise = throwError $ left `cannotUnify` right

-- |
-- Check if a type contains references to itself
--
occursCheck :: Unknown -> Type -> Boolean
occursCheck name (TUnknown name')
  | name == name' = true

occursCheck name (TLambda from to) = occursCheck name from || occursCheck name to

occursCheck _ _ = false

-- |
-- Bind a variable to a type in a substitution
--
bindVariable :: forall m. MonadError UnificationErrors m => Unknown -> Type -> UnifyT m (Substitution Type)
bindVariable name ty
  | occursCheck name ty = throwError $ recursiveType { varName: "t" <> show name, ty }
  | otherwise = pure $ Substitution $ Map.singleton name ty

-- Unification related errors:
--
-- |
-- Details for errors generated by the fact a type contains references to itself
--
type RecursiveTypeDetails
  = { ty :: Type
    , varName :: String
    }

-- |
-- Kind of errors which can occur during unification
--
type UnificationErrorKinds r
  = ( cannotUnify :: Tuple Type Type
    , recursiveType :: RecursiveTypeDetails
    | r
    )

-- |
-- Pretty print an inference error
--
showUnificationError :: Variant (UnificationErrorKinds ()) -> String
showUnificationError =
  (prefix <> _)
    <<< match
        { recursiveType:
          \{ ty, varName } ->
            "Type\n"
              <> (indent 4 $ varName <> " = " <> show ty)
              <> "\ncontains a reference to itself."
        , cannotUnify:
          \(Tuple left right) ->
            joinWith "\n"
              [ "Cannot unify type"
              , indent 4 $ show left
              , "with type"
              , indent 4 $ show right
              ]
        }
  where
  prefix = "UnificationError: "

-- |
-- Helper to create a recursiveType error
--
recursiveType :: RecursiveTypeDetails -> UnificationErrors
recursiveType data' =
  SteinerError
    { error: inj (SProxy :: SProxy "recursiveType") data'
    , showErr: showUnificationError
    , source: Nil
    }

-- |
-- Helper to create a cannotUnify error
--
cannotUnify :: Type -> Type -> UnificationErrors
cannotUnify left right =
  SteinerError
    { error: inj (SProxy :: SProxy "cannotUnify") $ Tuple left right
    , showErr: showUnificationError
    , source: Nil
    }

-- |
-- Errors which occur during unification
--
type UnificationErrors
  = SteinerError (UnificationErrorKinds ())
